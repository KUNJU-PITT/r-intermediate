---
title: "Writing Functions in R"
author: "Mark Dunning"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output: slidy_presentation
---

# User functions

## Introducing user functions

* All R commands are function calls
* Functions take some input, perform calculations on that input, and return some output
* e.g. `sqrt` is a function that takes a value, calculates the square root of the value, and returns the square root
* `aov` takes a formula referring to some data, calculate the analysis of variance for that data, and returns the model it calculated
* We can define our own functions. User functions extend the capabilities of R by adapting or creating new tasks that are tailored to your specific requirements
*  User functions are objects, just like vectors and data frames. This has a few useful implications

##Defining a new function

* A function has a name, arguments, procedural steps, and a return value
```{r}
sqXplusX <- function(x){
  x^2 +x
}
```

* `sqXplusX` is the function name
* `x` is the single argument to this function and it exists only within the function
* everything between the brackets `{}` are procedural steps
* the last calculated value is the function return value. We can call `return` explictly
* after defining the function, we can use it:
```{r}
sqXplusX(10)
```

## Named and default arguments

* We can generalise our function by adding a second argument

```{r}
powXplusX <- function(x, power=2){
  x^power + x
}
```
* The `power` argument has a default value of 2; if we don't supply a power when we call the function, `x` will be squared
* Arguments without a default value are required, those with default values are optional
```{r}
powXplusX(10) #arguments are matched based on position
powXplusX(10, 3) #arguments are matched based on position
powXplusX(x=10, power=3) # arguments matched based on name
```

## Calculation with user functions

* User functions can be used wherever a built-in function can be used:

```{r eval=FALSE}
#make some example data
a <- matrix(1:100, ncol=10, byrow=TRUE) 
sqXplusX(a)
```

* Functions are R objects, just like a vector or a data frame, and exist in our workspace

```{r}
sqXplusX
```

## Variable scope

* Objects created in functions are not available to the global environment unless returned. They are limited to the scope of the function
```{r}
addone <- function(x) {x <- x+1; x}
x <-1
addone(x)
x
```

* The `x` in the global environment has nothing to do with the `x` declared in the function, and is unchanged by the call to the function. To update the global `x`, we would need to assign the return value of the function

```{r}
x <- addone(x)
```
* A function can only return one object, but that object can be a list, so if you have many objects to return, package them up into a list first


## Script / function tips

* If your script repeats the same command with different values more than twice, you should consider writing a function to generalise that command

* Writing functions makes your code more easily understandable because they encapuslate a procedure into a well-defined boundary with consistent input/output

* Functions should only do one thing. If a function is doing multiple tasks, try to split it up into multiple functions. This rule of thumb means functions tend to be short, not more than around one or two screens of code

* Look at other functions to get ideas for how to write your own.
    + Display function code by entering the function's name without brackets `()`
    
## Checking input and reporting errors

* A function should fail gracefully if it does not receive valid input when it is called. We can use `if` statements to check for appropriate input

* R has two useful commands to tell the user something is wrong. 
    + `warning` prints a message and continues to run the function. 
    + `stop` ends the function after printing the message.

* For example, we might rewrite our `powXplusX` function to check that the power argument is a whole number:

```{r}
powXplusX <- function(x, power=2){
  if(power %% 1 != 0) stop ("Power should be a whole number")
  x^power + x
}
```

```{r}
powXplusX(10, 3)
```

```{r eval=FALSE}
powXplusX(10, 3.5)

```

```{r echo=FALSE}
err <- try(powXplusX(10, 3.5),silent = TRUE)
```

```{r echo=FALSE}
message(err[1])
```


## Checking input and reporting errors

* R has a very useful set of functions called the `is` family, which check the type of input values. For example:

```{r}
sqXplusX <- function(x){
  if (is.numeric(x)){
    x^2 + x
  } else {
    stop("Input should be numeric")
  }
}
```

```{r}
sqXplusX(10)
```

```{r eval=FALSE}
sqXplusX("ten")

```

```{r echo=FALSE}
err <- try(sqXplusX("ten"), silent = TRUE)
```

```{r echo=FALSE}
message(err[1])
```
The `is.` family consists of; `is.character`, `is.null`,`is.na` `is.data.frame` etc. For full list, type the following and press `TAB`
```{r eval=FALSE}
is.
```

## Checking input and reporting errors

* Here's another, more concise way to do the same thing:

```{r}
sqXplusX <- function(x){
  if(!is.numeric(x)) stop("Input should be numeric")
  x^2 + x
}
```

* This is not only shorter, but it also gets all the error checking out of the way before the main processing stesp

* You may also find the `%in%` command useful, which checks to see if the elements of one vector are present in another
```{r}
month.name

"May" %in% month.name
"Jan" %in% month.name
c("March", "April") %in% month.name
```

## Temperature conversion exercise

* Centigrade to Fahrenheit conversion is given by F = 9/5 *C +32
* Write a function that converts between temperatures
* The function should take two named arguments
    + temperature `t` is numeric
    + units `unit` is character
* Both arguments should have appropriate default values
* The function should report an appropriate error if inappropriate values are given
    + `if(!is.numeric(t)) { ...}`
    + `if(!(unit %in% c("c","f"))) {...}`
* The function should print out the temperature in Fahrenheit if given in Centigrade, and vice-versa    


## Building the solution

* It is difficult to write large chunks of code. Instead, start with something that works and build upon it
* e.g. to solve the temperature conversion exercise:
    + write a skeleton function definition (e.g. just a name and brackets)
    + add appropriate argument names and defaults
    + write code to convert Centigrade to Fahrenheit and check it works
    + write code to convert Fahrenheit to Centigrade and check it works
    + add error-checking code, including the checks from the previous slide, and any others you can think of
    + write a set of test calls to confirm that your function handles correct and incorrect input
* If you get stuck, call us for help

##Temperature conversion exercise script

```{r}
convTemp <- function(t=0, unit="c"){
# convTemp is defined as a new user function requiring two arguments, t and unit, the default values are 0 and "c", respectively. 
    if(!is.numeric(t)) stop("Non numeric 
                            temperature entered")
    if(!unit %in% c("c","f")){
    stop("Unrecognised temperature unit")
  }
  converted <- 0
  # conversion for centigrade
  if(unit == "c"){
    converted <- 9/5 * t + 32
  }
  #conversion for Fahrenheit
  if(unit == "f"){
    converted <- 5/9 * (t - 32)
  }
  converted
}


```
